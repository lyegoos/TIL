# 상속
- 기존의 클래스로 새로운 클래스를 작성하는 것( 코드의 재사용 )
- 두 클래스를 부모자식 관계 맺어주는 것
- 자손 클래스는 조상의 모든 멤버를 상속받는다. ( 생성자, 초기화블록은 제외 )
- 자손의 멤버 개수는 조상보다 적을 수 없다( 최소한 같거나 그보다 많다 )
- 자손 클래스의 변경은 조상에 영향을 미치지 않는다.


# 포함 관계
- 클래스의 멤버로 다른 클래스 타입의 참조변수를 선언하는 것

class Circle { // Circle이 Point를 포함
 Point c = new Point();
 int r;
}

 

# 클래스 간의 관계 결정하기
상속관계 : ~은 ~이다. (is-a)
포함관계 : ~은 ~을 가지고 있다. (has-a)

 

# 단일 상속
- Java는 단일 상속만을 허용한다
- 다중 상속처럼 사용하려면 비중높은 클래스 하나만 상속관계, 나머지는 포함관계로 한다

 

# Object 클래스 ( 모든 클래스의 조상 )
- 부모가 없는 클래스는 자동적으로 Object 클래스를 상속받는다.
- 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받음
(toString(), equals(Object obj), hashCode() 등... )

 

# 오버라이딩 ( overriding )
- 조상으로부터 상속받은 메서드를 자신에게 맞게 변경하는 것

# 오버라이딩 조건
- 오버라이딩하려면 메서드의 선언부가 조상 클래스의 메서드와 똑같아야 한다.
( 반환타입, 메서드 이름, 매개변수 목록 )
- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다
- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.


# 오버로딩 vs 오버라이딩
- 오버로딩 : 이름은 같지만 기존에 없는 새로운 메서드를 정의하는 것
- 오버라이딩 : 상속받은 메서드의 내용을 변경하는 것

 

# 참조변수 super
- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자)내에만 존재, static 메서드 내에서 사용불가
- 조상의 멤버를 자신의 멤버와 구별할 때 사용 ( this는 lv와 iv 구별에 사용 )
- 조상 클래스에 x 변수가 있는데 자손 클래스에도 x 변수가 존재할 때, 조상 클래스의 x는 super.x이고 자손 클래스의 x는 this.x이다.

 

# super() - 조상의 생성자
- 조상의 생성자를 호출할 때 사용
- 조상의 멤버는 조상의 생성자를 호출해서 초기화
- 자손의 생성자는 자손의 멤버만 초기화해야한다. 부모의 멤버를 초기화할때는 super()로 부모의 생성자를 호출해서 초기화한다.

 

class Point{
 int x, y;
 Point(int x, int y){
   this.x = x;
   this.y = y;
 }
}

 

class Point3D extends Point(int x, int y, int z){
 super(x, y); // x, y에 대해서는 이렇게 초기화해야 한다.
 this.z = z;
}

 

# - (중요!)

생성자의 첫 줄에 반드시 생성자를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입한다. ( 기본 생성자를 작성하는 게 필수이다! 기본 생성자가 없다면 자식 클래스의 생성자의 첫 줄에 다른 생성자가 없다면 super()를 호출하는데, 부모 클래스의 기본 생성자가 없다면 super()가 없는 것이기 때문에 에러가 발생한다! )

 

 

09.07 수정
