# 객체지향프로그래밍(OOP)



# 객체 지향의 개념! ( 규칙이며 외우자 )

1. 캡슐화

2. 상속

3. 추상화

4. 다형성



클래스의 정의 : 객체를 정의해 놓은 것
클래스의 용도 : 객체를 생성하는데 사용



객체의 정의 : 실제로 존재하는 것. 사물or개념
객체의 용도 : 객체가 가지고 있는 기능, 속성에 따라 다른 용도를 가지고 있다

객체 = 속성(변수) + 기능(메서드) 으로 이루어져 있다.



# - 객체와 인스턴스

객체 : 모든 인스턴스를 대표하는 일반적인 용어
인스턴스 : 특정 클래스로부터 생성된 객체를 의미



# - 객체 사용까지의 순서

1. 클래스(설계도) 작성
2. 객체(제품) 생성
3. 객체의 사용



Tv t; // Tv 클래스 타입(기본형이 아닌 참조형)의 참조변수 t를 선언
t = new Tv(); // Tv인스턴스를 생성(비어있는 메모리에 객체가 생성된다.) - new가 만들어진 객체의 주소를 반환해주는데 이를 참조변수 t에 대입해 객체와 참조변수를 연결

이후 객체를 조작하려면 무조건! 참조변수(타입이 Tv)를 통해서만 다룰 수 있다.

리모콘 타입과 생성하려는 객체의 타입이 일치해야 한다.



Tv t1 = new Tv();
Tv t2 = new Tv();
t1.channel = 7; 

참조변수 t1과 연결된 객체의 channel 변수를 7로 설정. t2와 연결된 객체의 channel 변수값은 바뀌지 않는다. 이름만 같을 뿐 서로 다른 변수이다. 만들어지는 객체마다 별도의 저장공간이 생긴다.



t2 = t1; 

이를 실행하면 t1과 연결되어있는 객체의 주소를 t2에 넣어준다. 이러면 t1과 연결돼있던 객체가 t2와도 연결된다. 한 TV를 리모콘 2개로 컨트롤한다고 생각하면 된다! 대신 t2와 연결되어있던 객체는 더 이상 사용할 수 없게 된다. 사용할 수 없게 된 객체는 GC(가비지컬렉터)가 메모리 상에서 제거한다.



참조변수 두 개가 한 객체를 가리킬 수 있다. but 하나의 참조변수에는 하나의 값만 들어갈 수 있기 때문에, 참조변수 하나로 2개 이상의 객체를 조작할 수는 없다!



# 객체 배열 == 참조변수 배열



Tv[] tvArr = new Tv[3];
참조변수 3개를 배열형태로 붙여놓은것

tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
간단히 표현하면 
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };


객체를 생성해서 배열에 들어있는 각 참조변수에 저장



주의! : 참조변수 배열을 만든 뒤 꼭 객체를 생성해서 채워넣어야 사용할 수 있다. 배열만 만든다면 객체없이 참조변수만 존재한다.



# 클래스의 정의 3가지 - 설계도 / 데이터+함수(서로 관련되어있는 것을 묶어둠) / 사용자 정의 타입



# -선언 위치에 따른 변수의 종류
영역으로 구분 - 1. 클래스영역(iv, cv) 2. 메서드영역(lv)

cv는 iv 앞에 static 키워드가 붙은 변수



클래스 영역에는 선언문만 가능(변수 선언, 메서드선언)



# 생성시기로 구분

- lv(변수 선언문이 수행됐을 때, 메서드가 끝날때까지만 유효)

- iv(인스턴스가 생성됐을 때/중요!)

- cv(클래스가 메모리에 올라갈 때/객체를 만들기전에 클래스가 메모리에 먼저 올라가야한다./객체를 만들지않더라도 생성된다.)



객체마다 다른 고유의 값을 필요로 한다면 iv로 선언.
객체들이 가져야 할 공통적인 속성에 대한 값은 cv로 선언



cv의 값을 설정해주려면 객체참조변수명.cv = 값;
이 아니라 클래스명.cv = 값;
이런식으로 써줘야한다.



iv는 객체당 1개씩 존재하며, cv는 객체들끼리 공유되므로 객체에 있는게 아니라 다른 공간에 따로 한 개만 만들어져있어 메모리공간을 절약한다.



# - 메서드

메서드는 클래스 안에 있어야한다. 함수는 클래스에 독립적이다. 근본적으로는 같은 것
값(입력)을 받아서 처리한 다음 그 결과를 반환(출력)해준다.



# 메서드의 장점
- 코드의 중복을 줄일 수 있다.
- 코드의 관리가 쉽다.
- 코드를 재사용할 수 있다.
- 코드가 간결해서 이해하기 쉬워진다.

 

메서드 = 선언부 + 구현부 로 이루어져 있다.

 

# 지역변수(lv) : 메서드 내에 선언된 변수로 메서드가 끝날 때까지 유효하다.
# 매개변수도 지역변수다!

 

# 호출 스택
메서드 수행에 필요한 메모리가 제공되는 공간
메서드가 호출되면 호출스택에 메모리를 할당한다. 메서드가 종료되면 할당된 메모리가 해제된다
스택의 맨 위에 올라와있는 메서드만 실행중이며, 그 아래 들어가있는 메서드들은 차례가 올 때까지 대기한다.

 

# 기본형 매개변수
- 변수의 값을 읽기만 할 수 있다.(read only, 수정X)
# 참조형 매개변수
- 변수의 값을 읽고 변경할 수 있다.(read & write)


# static 메서드와 인스턴스 메서드

⊙static 메서드(클래스 메서드)
- 객체 생성없이 '클래스이름.메서드이름()'으로 호출한다.
- 인스턴스 멤버(iv,im)와 관련없는 작업을 하는 메서드
- 메서드 내에서 인스턴스 변수(iv) 사용불가
- iv가 필요없다 = 객체(iv 묶음)가 필요없다

 

static 메서드는 객체 생성없이 호출 가능하다.
같은 클래스 안에 있는 경우는 참조변수를 표시하지 않아도 메서드를 쓸 수 있다.

 

static 메서드는 iv를 사용할 수 없으면서, 인스턴스 메서드(im)도 호출할 수 없다!
- why? static은 항상 호출 가능하지만 iv, im은 객체가 있어야하는데 객체가 없는 상황일 수도 있기 때문에 호출 불가능하다.

 

⊙인스턴스 메서드
- 인스턴스 생성 후 '참조변수이름.메서드이름()'으로 호출
- 인스턴스 멤버(iv,im)와 관련된 작업을 하는 메서드
- 메서드 내에서 인스턴스 변수(iv) 사용가능
- iv로 작업을 하기 때문에 객체 생성(iv 생성)을 하지 않으면 사용할 수 없다!

 

# 메서드에 static을 붙일지 말지 어떻게 정할까?
- iv를 사용하지 않을 때 붙이면 된다!

 

# 객체는 iv들의 묶음! = 인스턴스 메서드를 사용 시에 매개변수없이 iv를 사용해서 동작할 수 있다.

 

# 오버로딩 ( overloading )
성립 조건
1. 메서드 이름이 같아야 한다.
2. 매개변수의 갯수 or 타입이 달라야 한다.
3. 반환 타입만 다른 것은 영향 없다.(반환타입만 다르면 중복정의)

long add ( int a, long b ) { return a+b; }
long add ( long a, int b ) { return a+b; }

이 경우에는 오버로딩이 성립하지만, add(3,3) 같이 메서드를 사용하면 두 메서드 중 무엇을 사용할지 모호하기(ambiguous) 때문에 컴파일러가 에러를 발생시킨다.

 

# 생성자(Constructor)
- 인스턴스가 생성될 때 호출되는 [인스턴스 초기화 메서드]
- iv 초기화를 편리하게 하려고 만든다.
- 생성자도 메서드이므로 오버로딩이 가능!
인스턴스 초기화 == iv 초기화

 

Ex] Time t = new Time(12,34,56)에서 Time(12,34,56)이 생성자를 호출하는 것

 

# 생성자 생성 규칙
- 이름이 클래스의 이름과 같아야 한다.
- 리턴값이 없다. (항상 리턴값이 없기에 void도 안 붙임)
- 모든 클래스는 반드시 생성자를 가져야 한다.

 

09.05 수정
