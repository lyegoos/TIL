# 상속
- 기존의 클래스로 새로운 클래스를 작성하는 것( 코드의 재사용 )
- 두 클래스를 부모자식 관계 맺어주는 것
- 자손 클래스는 조상의 모든 멤버를 상속받는다. ( 생성자, 초기화블록은 제외 )
- 자손의 멤버 개수는 조상보다 적을 수 없다( 최소한 같거나 그보다 많다 )
- 자손 클래스의 변경은 조상에 영향을 미치지 않는다.


# 포함 관계
- 클래스의 멤버로 다른 클래스 타입의 참조변수를 선언하는 것

class Circle { // Circle이 Point를 포함
 Point c = new Point();
 int r;
}

 

# 클래스 간의 관계 결정하기
상속관계 : ~은 ~이다. (is-a)
포함관계 : ~은 ~을 가지고 있다. (has-a)

 

# 단일 상속
- Java는 단일 상속만을 허용한다
- 다중 상속처럼 사용하려면 비중높은 클래스 하나만 상속관계, 나머지는 포함관계로 한다

 

# Object 클래스 ( 모든 클래스의 조상 )
- 부모가 없는 클래스는 자동적으로 Object 클래스를 상속받는다.
- 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받음
(toString(), equals(Object obj), hashCode() 등... )

 

# 오버라이딩 ( overriding )
- 조상으로부터 상속받은 메서드를 자신에게 맞게 변경하는 것

# 오버라이딩 조건
- 오버라이딩하려면 메서드의 선언부가 조상 클래스의 메서드와 똑같아야 한다.
( 반환타입, 메서드 이름, 매개변수 목록 )
- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다
- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.


# 오버로딩 vs 오버라이딩
- 오버로딩 : 이름은 같지만 기존에 없는 새로운 메서드를 정의하는 것
- 오버라이딩 : 상속받은 메서드의 내용을 변경하는 것

 

# 참조변수 super
- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자)내에만 존재, static 메서드 내에서 사용불가
- 조상의 멤버를 자신의 멤버와 구별할 때 사용 ( this는 lv와 iv 구별에 사용 )
- 조상 클래스에 x 변수가 있는데 자손 클래스에도 x 변수가 존재할 때, 조상 클래스의 x는 super.x이고 자손 클래스의 x는 this.x이다.

 

# super() - 조상의 생성자
- 조상의 생성자를 호출할 때 사용
- 조상의 멤버는 조상의 생성자를 호출해서 초기화
- 자손의 생성자는 자손의 멤버만 초기화해야한다. 부모의 멤버를 초기화할때는 super()로 부모의 생성자를 호출해서 초기화한다.

 

class Point{
 int x, y;
 Point(int x, int y){
   this.x = x;
   this.y = y;
 }
}

 

class Point3D extends Point(int x, int y, int z){
 super(x, y); // x, y에 대해서는 이렇게 초기화해야 한다.
 this.z = z;
}

 

# - (중요!)

생성자의 첫 줄에 반드시 생성자를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입한다. ( 기본 생성자를 작성하는 게 필수이다! 기본 생성자가 없다면 자식 클래스의 생성자의 첫 줄에 다른 생성자가 없다면 super()를 호출하는데, 부모 클래스의 기본 생성자가 없다면 super()가 없는 것이기 때문에 에러가 발생한다! )

 

# **· 접근제어자**  
class 앞에 붙일 수 있는 접근제어자는 public, default  
변수 앞에는 public, protected, default, private 가능하다  
  
**\- 접근제어자의 범위**  
private : 같은 클래스  
default : 같은 패키지  
protected : 같은 패키지 + 자손클래스(다른 패키지)  
public : 전부 가능. 접근제한 없음

  
# **· 캡슐화와 접근 제어자**  
  
**접근제어자를 사용하는 이유?**  
1. 외부로부터 데이터를 보호하기 위해서(캡슐화) - (ex)입력값이 0~23으로 정해진 데이터에 대해 다른 값을 입력하는 것을 막을 수가 없다.  
  
iv의 접근제어자를 private로 지정해 직접 접근을 막고, public 메서드를 통한 간접 접근을 허용한다.  
  
2. 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

# **· 다형성(polymorphism)**  
\- 여러가지 형태를 가질 수 있는 능력  
\- ☆조상 타입 참조 변수로 자손 타입 객체를 다루는 것  
  
Tv t = new SmartTv(); // 이런 식으로 타입이 불일치하더라도 OK인 것이 다형성 (리모콘은 Tv 타입이고 제품은 SmartTv 타입인 것)  
  
**다형성의 장점**  
SmartTv 인스턴스의 멤버변수가 7개(Tv 멤버변수 5개, SmartTv 멤버변수 2개 = 총 7개) - SmartTv 참조변수(리모콘)로 7개를 모두 사용 가능  
  
참조변수가 Tv인 경우, SmartTv 인스턴스가 가진 멤버변수는 7개지만 Tv 리모콘의 버튼은 5개뿐이다. 그래서 5개의 멤버변수만 사용 가능하다.  
  
  
\- 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.  
ex) SmartTv s = new Tv(); // 에러. Tv가 조상임  
※ 리모콘의 버튼은 7개인데 Tv 객체가 가진 멤버는 5개 뿐이다. (없는 기능을 호출하면 에러가 발생)  
  
  
**· 참조변수의 형변환**  
\- 사용할 수 있는 멤버의 갯수를 조절하는 것  
\- ☆조상, 자손 관계의 참조변수는 서로 형변환 가능  
\- 리모콘을 변경함으로서 사용할 수 있는 멤버변수의 갯수를 늘렸다 줄였다 하는 것  
\- 참조변수가 가리키는 실제 객체의 멤버 갯수가 중요. 실제 객체가 가지고 있는 멤버변수 갯수보다 작거나 같아야 한다.  
\- 형변환 시 타입만 맞으면 컴파일러는 OK한다. (속는다)  
\- 조상 객체를 사용할 경우 자손 참조변수 타입으로 형변환하면 조상 객체 멤버갯수보다 많을 수 있으므로 형변환이 가능하더라도 해서는 안 된다.  
  
  
**· instanceof 연산자**  
\- 참조변수의 형변환 가능여부 확인에 사용한다. 형변환 가능시 true 반환  
\- 형변환 전에 반드시 instanceof로 확인해야 한다.  
\- instanceof 뒤에 붙는 참조변수에 대해서, 앞의 참조변수가 자기자신이거나 자손 참조변수라면 true이다.   
ex) 조상객체 참조변수 instanceof 자손객체 참조변수 = 이 경우는 false

**· 정리**  
Q. 참조변수의 형변환은 왜 하는가?  
\- 참조변수(리모콘)를 변경함으로써 사용 가능한 멤버의 갯수를 조절하기 위해서  
Q. instanceof 연산자는 언제 사용하는가?  
\- 참조변수를 형변환하기 전에 형변환 가능여부를 확인할 때


# **· 다형성의 장점**  
1. 다형적 매개변수  
2. 하나의 배열로 여러 종류 객체를 다루는 것  
  
**· 매개변수의 다형성**  
\- 참조형 매개변수는 메서드 호출 시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다.  
\- 예를 들어 Product라는 클래스를 상속받는 Tv, Computer, Audio라는 클래스가 있다고 할 때, 각 제품에 대한 buy 메서드를 각각 오버로딩으로 구현해야한다는 단점이 있다. 새 제품이 추가될 때마다 buy 메서드를 추가해주어야 한다... 이를 다형성이 해결해주는데, buy 클래스의 매개변수로 그저 Product 참조변수를 넘겨주면 된다!  
  
ex)   
Product p = new Tv1();  
b.buy(p);  
  
# **ch7-29. 여러 종류의 객체를 배열로 다루기**  
\- 조상타입의 배열에 자손들의 객체를 담을 수 있다. (하나의 배열에 여러 종류 객체 저장)  
  
· Vector 클래스 - 가변 배열 기능  
\- ☆Object 배열이 있어 Vector 클래스에는 모든 종류의 객체를 저장할 수 있다.☆  
  
# **ch7-31. 추상 클래스(abstract class)**  
\- 미완성 메서드를 가지고 있는 클래스  
※ 미완성 메서드란? : 추상메서드. 몸통{}이 없는 메서드. 앞에 abstract라는 키워드가 붙는다.  
  
\- 다른 클래스 작성에 도움을 주기 위한 것으로 인스턴스(객체)를 생성할 수 없다.  
\- 추상 클래스를 상속받고, 상속받은 클래스에서 추상 메서드를 구현해야 인스턴스 생성 가능(상속받은 추상 메서드를 일부만 구현했다면 상속받은 클래스에도 abstract 제어자를 붙여줘야 한다.)

# **ch7-34. 추상 클래스의 작성**  
\- 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나, 기존 클래스들의 공통 부분을 뽑아서 추상클래스를 만든다. (이 추상클래스 타입의 배열을 만들면, 안에 넣은 여러 클래스들의 객체를 하나의 리모콘으로 조작가능한 효과가 있다.)  
  
\- 추상 클래스를 의미있는 단계별로 나누어 작성해두면 바꾸고 싶은 내용에 따라 상속받을 추상 클래스를 골라서 구현할 수 있다는 장점이 있다.  
  
**· 추상화가 구체화보다 좋은 점**  
\- 추상화 된 코드는 구체화된 코드보다 유연해 변경에 유리하다.  
  
# **ch7-35. 인터페이스(interface)**  
\- ☆추상 메서드의 집합☆(모든 메서드가 추상 메서드이므로 몸통부{}가 없다)  
\- 구현된 것이 전혀 없는 설계도. 껍데기(☆모든 멤버가 public☆)  
\- 인터페이스는 객체에서 가장 바깥의 껍데기 부분. 캡슐화의 개념에서 변수는 메서드를 통해서 접근하게 되는데 여기서 제일 바깥쪽에 항상 노출되어 있어 모든 멤버가 public이다.  
\- 추상 클래스와의 차이 : 추상 클래스는 일반 클래스인데 추상 메서드를 가지고 있는 것. 인터페이스는 추상 메서드만 가질 수 있다.(변수(iv)를 가질 수 없음. 상수는 가능)  
\- 인터페이스 안의 메서드는 항상 public abstract 이므로 이를 생략 가능하다. 상수는 항상 public static final 이므로 이것도 생략 가능  
  
# **ch7-36. 인터페이스의 상속**  
\- 인터페이스의 조상은 인터페이스만 가능(최고 조상이 Object가 아님)  
\- 다중 상속이 가능하다.(조상이 여러개) : 클래스 상속에선 내용이 다르고 선언부가 같은 메서드가 두 조상에서 각각 존재하면 어느 메서드를 상속받을지 충돌나기 때문에 안되지만, 인터페이스에서는 메서드의 몸통이 없기 때문에 이름이 같은 메서드가 있어도 상관없다.  
  
# **ch7-37. 인터페이스의 구현**  
\- 인터페이스에 정의된 추상 메서드를 완성하는 것  
\- class가 <implements 인터페이스이름> 을 통해 인터페이스를 상속받아 인터페이스에 정의된 추상 메서드를 모두 구현한다.  
\- 클래스에서 인터페이스를 상속받아 구현 시, 일부 추상메서드만 구현했다면 클래스 앞에 abstract를 붙여야 한다.  
  
# **ch7-38. 인터페이스를 이용한 다형성**  
\- 인터페이스 타입 매개변수는, 즉 매개변수의 타입이 인터페이스인 경우에는 그 인터페이스를 구현한 클래스의 객체만 가능  
\- 인터페이스를 메서드의 리턴타입으로 지정할 수 있다. (메서드의 리턴 타입으로 지정한 인터페이스를 구현한, 클래스의 인스턴스를 반환하겠다는 의미)

10.24 수정
